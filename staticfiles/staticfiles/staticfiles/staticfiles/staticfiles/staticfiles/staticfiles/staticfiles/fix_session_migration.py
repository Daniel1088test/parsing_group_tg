#!/usr/bin/env python3
"""
Script to fix the TelegramSession model by adding is_authorized field
"""
import os
import sys
import django
import logging
import traceback

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
)
logger = logging.getLogger('fix_session')

# Setup Django
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'core.settings')
django.setup()

# Import the required modules after Django setup
from django.db import connection
from django.db.utils import ProgrammingError, OperationalError

def fix_session_table():
    """Add missing fields to TelegramSession model"""
    with connection.cursor() as cursor:
        try:
            # Check if is_authorized field exists
            try:
                cursor.execute("SELECT is_authorized FROM admin_panel_telegramsession LIMIT 1")
                logger.info("is_authorized field already exists")
            except (ProgrammingError, OperationalError) as e:
                logger.info(f"Field is_authorized does not exist: {e}")
                # Add the field
                logger.info("Adding is_authorized field to admin_panel_telegramsession table...")
                
                # PostgreSQL syntax
                try:
                    cursor.execute("ALTER TABLE admin_panel_telegramsession ADD COLUMN is_authorized BOOLEAN DEFAULT FALSE")
                    logger.info("Successfully added is_authorized field using PostgreSQL syntax")
                except Exception as pg_e:
                    logger.warning(f"PostgreSQL ALTER failed for is_authorized: {pg_e}")
                    
                    # SQLite syntax
                    try:
                        cursor.execute("ALTER TABLE admin_panel_telegramsession ADD COLUMN is_authorized BOOLEAN DEFAULT 0")
                        logger.info("Successfully added is_authorized field using SQLite syntax")
                    except Exception as sqlite_e:
                        logger.error(f"SQLite ALTER failed for is_authorized: {sqlite_e}")
            
            # Check if last_activity field exists
            try:
                cursor.execute("SELECT last_activity FROM admin_panel_telegramsession LIMIT 1")
                logger.info("last_activity field already exists")
            except (ProgrammingError, OperationalError) as e:
                logger.info(f"Field last_activity does not exist: {e}")
                # Add the field
                logger.info("Adding last_activity field to admin_panel_telegramsession table...")
                
                # PostgreSQL syntax
                try:
                    cursor.execute("ALTER TABLE admin_panel_telegramsession ADD COLUMN last_activity TIMESTAMP WITH TIME ZONE DEFAULT NOW()")
                    logger.info("Successfully added last_activity field using PostgreSQL syntax")
                except Exception as pg_e:
                    logger.warning(f"PostgreSQL ALTER failed for last_activity: {pg_e}")
                    
                    # SQLite syntax
                    try:
                        cursor.execute("ALTER TABLE admin_panel_telegramsession ADD COLUMN last_activity TIMESTAMP DEFAULT CURRENT_TIMESTAMP")
                        logger.info("Successfully added last_activity field using SQLite syntax")
                    except Exception as sqlite_e:
                        logger.error(f"SQLite ALTER failed for last_activity: {sqlite_e}")
            
            return True
        except Exception as e:
            logger.error(f"Error fixing session table: {e}")
            logger.error(traceback.format_exc())
            return False

def create_migration_file():
    """Create a migration file if makemigrations can't be used"""
    try:
        migration_dir = os.path.join('admin_panel', 'migrations')
        os.makedirs(migration_dir, exist_ok=True)
        
        # Find the next migration number
        existing_migrations = [f for f in os.listdir(migration_dir) if f.endswith('.py') and f[0].isdigit()]
        existing_migrations.sort()
        
        if existing_migrations:
            last_num = int(existing_migrations[-1].split('_')[0])
            next_num = str(last_num + 1).zfill(4)
        else:
            next_num = '0001'
        
        # Create the migration file
        migration_file = os.path.join(migration_dir, f"{next_num}_add_is_authorized_field.py")
        
        with open(migration_file, 'w') as f:
            f.write("""# Generated by fix_session_migration.py

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('admin_panel', '{}'),
    ]

    operations = [
        migrations.AddField(
            model_name='telegramsession',
            name='is_authorized',
            field=models.BooleanField(default=False, verbose_name='Авторизована'),
        ),
    ]
""".format(existing_migrations[-1].split('.')[0] if existing_migrations else '0001_initial'))
        
        logger.info(f"Created migration file: {migration_file}")
        return True
    except Exception as e:
        logger.error(f"Error creating migration file: {e}")
        return False

def main():
    logger.info("Starting fix for TelegramSession model...")
    
    # Try to fix the table directly
    if fix_session_table():
        logger.info("Table fixed directly, no migration needed")
        return True
    
    # If direct fix fails, create a migration file
    if create_migration_file():
        logger.info("Migration file created successfully")
        
        # Try to run the migration
        try:
            from django.core.management import call_command
            call_command('migrate', 'admin_panel')
            logger.info("Migration applied successfully")
            return True
        except Exception as e:
            logger.error(f"Error applying migration: {e}")
            logger.error("Please run 'python manage.py migrate admin_panel' manually")
    
    return False

if __name__ == "__main__":
    success = main()
    sys.exit(0 if success else 1) 